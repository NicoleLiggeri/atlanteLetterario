<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Globe Visualization</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.6.0/nouislider.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.6.0/nouislider.min.css">
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display&display=swap" rel="stylesheet">
<link rel="stylesheet" href="style.css">


  <script src="//unpkg.com/globe.gl"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  
</head>
<body>
  <div id="cover">
    <h1>L'Atlante dei temi letterari</h1>
    <button id="start-button">Mappa</button>
    <button id="info-button"><a href="theme.html">Gerarchia</a></button>
    <button id="contact-button">Contact Us</button>
  </div>

  <div id="app" class="one-column">

    <header>
        <div>L'Atlante dei temi letterari</div>
        
        <div id="search-container">
            <input id="search-input" type="text" placeholder="Digita un tema...">
            <ul id="suggestions-list"></ul>
            <button id="search-button">Cerca</button>
          </div>
        
      </header>
    <div id="globe-container">
      <div id="globeViz"></div>
    </div>

    <div id="right-panel">


    <div class="wrapper">
        <p class="filtered-info">Filtra per date d'autore</p>
  <div class="values">
    
    <span id="range1">
      0
    </span>

    <span id="range2">
      100
    </span>
  </div>
  <div class="container">
    
    <div class="slider-track"></div>
    <input type="range" min="0" max="2025" value="30" id="slider-1" oninput="slideOne()">
    <input type="range" min="0" max="2025" value="2025" id="slider-2" oninput="slideTwo()">
  </div>
</div>
      
      <div id="data-panel">
        <h3>Autori correlati:</h3>
        <h4 class="filtered-info">clicca sulla mappa per filtrare</h4>
        <div id="list-auth">
        <ul id="data-list"></ul>
        </div>
      </div>
    </div>
    <!-- Modal Structure -->
<!-- Modal Structure -->
<!-- Modal for displaying author details -->
<div id="author-details-modal" class="modal">
    <div class="modal-content">
      <span class="close" id="close-modal">&times;</span>
      <h2 id="author-name"></h2>
      <p id="author-years"></p>
      <h3>Themes</h3>
      <div id="author-themes"></div>
    </div>
  </div>
  
  
  
    <footer>
      Footer content here
    </footer>
  </div>

  <script>
    let world;
    let countriesData;
    let data = [];
    let associationsData = {};
  
    // Handle initial cover display
    document.getElementById('start-button').addEventListener('click', () => {
      document.getElementById('cover').style.display = 'none';
      document.getElementById('app').style.display = 'grid';
    });

  


  
    document.getElementById('contact-button').addEventListener('click', () => {
      alert('Contact us at support@example.com.');
    });
  
    // Load the primary data (authors, etc.)
    fetch('https://raw.githubusercontent.com/NicoleLiggeri/retetematica/refs/heads/main/datasets/data.json')
      .then(res => res.json())
      .then(json => { data = json; });
  
    // Load the associations data
    fetch('https://raw.githubusercontent.com/NicoleLiggeri/retetematica/refs/heads/main/datasets/hierarchy_themes.json')
      .then(res => res.json())
      .then(json => { associationsData = json; });
      let countryMapping = {}; // Oggetto che conterrÃ  la mappatura

// Funzione per caricare il CSV e creare la mappatura
function loadCountryMapping() {
  fetch("https://raw.githubusercontent.com/NicoleLiggeri/retetematica/refs/heads/main/datasets/mapping_ei.csv") // ðŸ”¹ Sostituisci con il percorso reale del CSV
    .then(response => response.text())
    .then(csvText => {
      const rows = csvText.split("\n").map(row => row.trim()).filter(row => row);
      rows.forEach(row => {
        const [english, italian] = row.split(","); // ðŸ”¹ Assumiamo che sia un CSV senza virgolette
        if (english && italian) {
          countryMapping[english.trim()] = italian.trim();
        }
      });
      console.log("Mappatura Paesi Caricata:", countryMapping); // ðŸ”¹ Debug per verificare la mappatura
    })
    .catch(error => console.error("Errore nel caricamento del CSV:", error));
}

// Chiamare la funzione per caricare la mappatura allâ€™avvio della pagina
loadCountryMapping();
 
    // Load globe and countries data
fetch('https://raw.githubusercontent.com/vasturiano/globe.gl/master/example/datasets/ne_110m_admin_0_countries.geojson')
      .then(res => res.json())
      .then(countries => {
        countriesData = countries.features;
        world = new Globe(document.getElementById('globeViz'))
          .backgroundColor('#e4f2f7')
          .globeImageUrl('https://upload.wikimedia.org/wikipedia/commons/a/ac/World_location_map.svg')
          .polygonsData(countriesData)
          .polygonCapColor(() => '#a9baba')
          .polygonSideColor(() => 'rgba(132, 145, 145, 1)')
          .polygonStrokeColor(() => '#111')
          .onPolygonClick(({ properties: d }) => {
            const clickedCountry = d.ADMIN;
            const startYear = parseInt(document.getElementById('slider-1').value);
            const endYear = parseInt(document.getElementById('slider-2').value);
            const temaKeyword = cleanText(document.getElementById('search-input').value.trim());  // Tema from the search input
  
              // Usa la mappatura caricata dal CSV
              const italianCountry = countryMapping[clickedCountry] || clickedCountry;
              
              // Modifica il titolo del pannello laterale
              const header = document.querySelector("#data-panel h3");
              if (header) {
                header.innerHTML = `Autori correlati ${italianCountry}:`;
              }

            // Filter authors based on country and timeline range
            const countryMatches = data.filter(item => 
              item["Citizenship Label"] === clickedCountry &&
              cleanText(item["Temi"]).includes(temaKeyword)  // Match Tema keyword
            );
  
            // Further filter authors based on timeline (birth and death years)
            const filteredAuthors = countryMatches.filter(item => {
              const birthYear = parseInt(item["Formatted Year of Birth"]);
              const deathYear = item["Formatted Year of Death"] === "Error: invalid syntax (<unknown>, line 0)" ? null : parseInt(item["Formatted Year of Death"]);
              const isWithinYearRange = (birthYear >= startYear && birthYear <= endYear) ||
                                        (deathYear && deathYear >= startYear && deathYear <= endYear);
              return isWithinYearRange;
            });
  
            // Update the right panel with authors
            const authors = filteredAuthors.map(item => item["Autore"]);
            const dataList = document.getElementById('data-list');
            dataList.innerHTML = '';  // Clear previous list
            authors.forEach(author => {
              const listItem = document.createElement('li');
              listItem.textContent = author;
              dataList.appendChild(listItem);
            });
  

          });
  
        world.pointOfView({ lat: 40, lng: 20, altitude: 1 }); // Adjust altitude for zoom level
      });



  
    // Utility to clean text (remove punctuation, normalize spaces, make lowercase)
    const cleanText = (text) => text.toLowerCase().replace(/[^\w\s]/g, '').trim();
  
    // Handle search button click
    document.getElementById('search-button').addEventListener('click', () => {
      const keyword = document.getElementById('search-input').value.trim();
      const startYear = parseInt(document.getElementById('start-year').value);  // Get start year from the slider
      const endYear = parseInt(document.getElementById('end-year').value);  // Get end year from the slider
  
      if (!keyword) return alert('Please enter a keyword.');
  
      const cleanedKeyword = cleanText(keyword);
  
      // Filter by keyword and year range
      const matches = data.filter(item => {
        const birthYear = parseInt(item["Formatted Year of Birth"]);
        const deathYear = item["Formatted Year of Death"] === "Error: invalid syntax (<unknown>, line 0)" ? null : parseInt(item["Formatted Year of Death"]);
  
        // Check if the keyword matches
        const isKeywordMatch = cleanText(item["Temi"]).split(',').map(t => t.trim()).some(t => t.toLowerCase() === cleanedKeyword);
  
        // Check if the author was active during the selected year range
        const isWithinYearRange = (birthYear >= startYear && birthYear <= endYear) || (deathYear && deathYear >= startYear && deathYear <= endYear);
  
        return isKeywordMatch && isWithinYearRange;
      });
  
      const countryOccurrences = matches.reduce((acc, item) => {
        const country = item["Citizenship Label"];
        acc[country] = (acc[country] || 0) + 1;
        return acc;
      }, {});
  
      // Update globe colors based on matches
      if (world && countriesData) {
        world.polygonCapColor(({ properties: d }) => {
          const count = countryOccurrences[d.ADMIN] || 0;
          return count > 0 ? `rgba(255, 244, 75, ${Math.min(count / 10, 1)})` : '#aaaaaa';
        });
      }
  
      // Update the right panel with authors
      const authors = matches.map(item => item["Autore"]);
      const dataList = document.getElementById('data-list');
      dataList.innerHTML = '';  // Clear previous list
      authors.forEach(author => {
        const listItem = document.createElement('li');
        listItem.textContent = author;
        dataList.appendChild(listItem);
      });
    });
  
    // Handle timeline input changes
    const startYearInput = document.getElementById('slider-1');
    const endYearInput = document.getElementById('slider-2');
    const searchInput = document.getElementById('search-input');  // to make sure keyword is always considered
    const searchButton = document.getElementById('search-button'); // to keep the functionality
    const dataList = document.getElementById('data-list'); // the list of authors
  
    const triggerSearch = () => {
  const keyword = searchInput.value.trim();
  const startYear = parseInt(startYearInput.value);
  const endYear = parseInt(endYearInput.value);

  if (!keyword) return alert('Please enter a keyword.');

  const cleanedKeyword = cleanText(keyword);
  const wrapper = document.querySelector('.wrapper');

  // Doppio controllo per sicurezza
  if (!keyword) {
    return alert('Inserisci un tema!');
  }

  // Filtra i dati per tema (corrispondenza esatta, ignorando case) e per range di anni
  const matches = data.filter(item => {
    const birthYear = parseInt(item["Formatted Year of Birth"]);
    const deathYear =
      item["Formatted Year of Death"] === "Error: invalid syntax (<unknown>, line 0)"
        ? null
        : parseInt(item["Formatted Year of Death"]);

    const isKeywordMatch = cleanText(item["Temi"])
      .split(',')
      .map(t => t.trim())
      .some(t => t.toLowerCase() === cleanedKeyword);

    const isWithinYearRange =
      (birthYear >= startYear && birthYear <= endYear) ||
      (deathYear && deathYear >= startYear && deathYear <= endYear);

    return isKeywordMatch && isWithinYearRange;
  });

  // Se non ci sono risultati, interrompi la funzione senza aggiornare il layout
  if (matches.length === 0) {
    alert('Nessun risultato trovato per il tema e i criteri selezionati.');
    return;
  }

  // Mostra il wrapper se nascosto
  if (wrapper && (wrapper.style.display === 'none' || wrapper.style.display === '')) {
    wrapper.style.display = 'block';
  }

  // **** Aggiornamento del layout del DOM ****
  // Il container #app inizia con layout a colonna singola ("one-column")
  // e, al trigger della prima ricerca, viene trasformato in layout a due colonne ("two-columns")
  const app = document.getElementById('app');
  const rightPanel = document.getElementById('right-panel');
  if (app.classList.contains('one-column')) {
    app.classList.remove('one-column');
    app.classList.add('two-columns');
  }
  // Rende visibile il right-panel
  rightPanel.style.display = 'block';
  // *******************************************

  // Recupera il tema selezionato dall'input
  const selectedTheme = searchInput.value.trim();
  if (!selectedTheme) {
    return alert('Inserisci un tema!');
  }

  // Aggiunge (o aggiorna) un <h1> con il tema selezionato come link nel right-panel
  let themeHeader = document.getElementById('theme-header');
  if (!themeHeader) {
    themeHeader = document.createElement('h1');
    themeHeader.id = 'theme-header';
    // Inserisce l'h1 all'inizio del right-panel
    rightPanel.insertBefore(themeHeader, rightPanel.firstChild);
  }
  themeHeader.innerHTML = `<a href="#" id="theme-link">${selectedTheme}</a>`;

  // Associa un listener al link per mostrare i dettagli del tema
  document.getElementById('theme-link').addEventListener('click', (e) => {
    e.preventDefault();
    fetchThemeDetails(selectedTheme);
  });

  // Calcola le occorrenze per paese
  const countryOccurrences = matches.reduce((acc, item) => {
    const country = item["Citizenship Label"];
    acc[country] = (acc[country] || 0) + 1;
    return acc;
  }, {});

  // Aggiorna i colori del globo in base ai matches
  if (world && countriesData) {
    world.polygonCapColor(({ properties: d }) => {
      const count = countryOccurrences[d.ADMIN] || 0;
      return count > 0 ? `rgba(232, 232, 39, ${Math.min(count / 10, 1)})` : '#aaaaaa';
    });
  }

  // **** Ripristina l'header degli autori ****
  // Se l'header Ã¨ stato modificato (ad es. "Autori correlati Spagna:"), lo ripristina a "Autori correlati:"
  const dataPanel = document.getElementById('data-panel');
  const authorsHeader = dataPanel.querySelector('h3');
  if (authorsHeader) {
    authorsHeader.textContent = "Autori correlati:";
  }
  // *******************************************

  // Aggiorna il pannello laterale con gli autori trovati
  const authors = matches.map(item => item["Autore"]);
  const dataList = document.getElementById('data-list');

  dataList.innerHTML = '';  // Pulisce la lista precedente

  if (authors.length > 0) {
    dataPanel.style.display = 'block';
    authors.forEach(author => {
      const listItem = document.createElement('li');
      listItem.textContent = author;
      dataList.appendChild(listItem);
    });
  } else {
    dataPanel.style.display = 'none';
    alert('No authors found for the selected country and criteria.');
  }
};

startYearInput.addEventListener('input', () => {
  const header = document.querySelector("#data-panel h3");
  if (header && header.textContent.trim() !== "Autori correlati:") {
    header.textContent = "Autori correlati:";
  }
  triggerSearch();
});

endYearInput.addEventListener('input', () => {
  const header = document.querySelector("#data-panel h3");
  if (header && header.textContent.trim() !== "Autori correlati:") {
    header.textContent = "Autori correlati:";
  }
  triggerSearch();
});

  
    // Optional: Trigger search when the search button is clicked too, in case users press it manually
    searchButton.addEventListener('click', triggerSearch);
    // Modal Elements
const modal = document.getElementById('author-modal');
const modalContent = document.getElementById('modal-content');
const closeModal = document.getElementById('close-modal');
const authorName = document.getElementById('author-name');
const authorBirthDeath = document.getElementById('author-birth-death');

// Handle click events on author list
// Function to handle clicking on an author
document.getElementById('data-list').addEventListener('click', (event) => {
  const clickedAuthor = event.target.textContent;

  // Find all entries for the clicked author
  const authorEntries = data.filter(item => item["Autore"] === clickedAuthor);

  if (authorEntries.length > 0) {
    const uniqueThemes = [
      ...new Set(authorEntries.flatMap(item => item["Temi"].split(',').map(theme => theme.trim())))
    ];

    // Populate the modal
    document.getElementById('author-name').textContent = clickedAuthor;
    document.getElementById('author-years').textContent =
      `${authorEntries[0]["Formatted Year of Birth"] || 'Unknown'} - ${authorEntries[0]["Formatted Year of Death"] || 'Unknown'}`;
    const themesContainer = document.getElementById('author-themes');
    themesContainer.innerHTML = '';
    uniqueThemes.forEach(theme => {
  const themeLink = document.createElement('a');
  themeLink.textContent = theme;
  themeLink.href = '#';
  themeLink.classList.add('theme-link');
  themeLink.addEventListener('click', (e) => {
    e.preventDefault();
    showDendrogramForTheme(theme);
  });
  themesContainer.appendChild(themeLink);
});


    // Show the modal
    document.getElementById('author-details-modal').style.display = 'block';
  } else {
    alert('No details found for the selected author.');
  }
});

// Function to fetch theme details and dynamically update the page
function fetchThemeDetails(theme) {
  fetch('https://raw.githubusercontent.com/NicoleLiggeri/retetematica/refs/heads/main/datasets/hierarchy_themes.json')
    .then(response => response.json())
    .then(dataset => {
      const normalizedTheme = theme.toLowerCase();  // Normalize the theme
      const associatedThemes = dataset[normalizedTheme]?.Associati;

      if (associatedThemes) {
        // Replace current page content
        document.body.innerHTML = `
          <h2>Associated Themes for "${theme}"</h2>
          <ul>
            ${associatedThemes.map(t => `<li><a href="#" class="theme-link" onclick="fetchThemeDetails('${t}')">${t}</a></li>`).join('')}
          </ul>
          <button onclick="window.location.reload()">Back to Authors</button>
        `;
      } else {
        alert(`No associated themes found for "${theme}".`);
      }
    })
    .catch(error => {
      console.error('Error fetching theme details:', error);
      alert('An error occurred while fetching theme details.');
    });
}

// Close modal functionality
document.getElementById('close-modal').addEventListener('click', () => {
  document.getElementById('author-details-modal').style.display = 'none';
});


window.onload = function () {
  slideOne();
  slideTwo();
};


let sliderOne = document.getElementById("slider-1");
let sliderTwo = document.getElementById("slider-2");
let displayValOne = document.getElementById("range1");
let displayValTwo = document.getElementById("range2");
let minGap = 0;
let sliderTrack = document.querySelector(".slider-track");
let sliderMaxValue = document.getElementById("slider-1").max;

function slideOne() {
  if (parseInt(sliderTwo.value) - parseInt(sliderOne.value) <= minGap) {
    sliderOne.value = parseInt(sliderTwo.value) - minGap;
  }
  displayValOne.textContent = sliderOne.value;
  fillColor();
}
function slideTwo() {
  if (parseInt(sliderTwo.value) - parseInt(sliderOne.value) <= minGap) {
    sliderTwo.value = parseInt(sliderOne.value) + minGap;
  }
  displayValTwo.textContent = sliderTwo.value;
  fillColor();
}
function fillColor() {
  percent1 = (sliderOne.value / sliderMaxValue) * 100;
  percent2 = (sliderTwo.value / sliderMaxValue) * 100;
  sliderTrack.style.background = `linear-gradient(to right, #dadae5 ${percent1}% , #3264fe ${percent1}% , #3264fe ${percent2}%, #dadae5 ${percent2}%)`;
}


// Variabile globale per memorizzare l'indice del suggerimento attivo
let suggestionIndex = -1;

// Supponiamo che 'themes' sia giÃ  popolato con i temi estratti dal database usato in triggerSearch()
// Ad esempio, se non lo hai giÃ , puoi popolarlo cosÃ¬ (oppure usando il tuo metodo attuale):
let themes = [];

function extractThemesFromData() {
  const themesSet = new Set();
  data.forEach(item => {
    if (item["Temi"]) {
      // Supponiamo che i temi siano separati da virgola
      item["Temi"].split(',').forEach(theme => {
        themesSet.add(theme.trim());
      });
    }
  });
  themes = Array.from(themesSet);
}

fetch('https://raw.githubusercontent.com/NicoleLiggeri/retetematica/refs/heads/main/datasets/data.json')
  .then(res => res.json())
  .then(json => { 
    data = json;
    extractThemesFromData();
  })
  .catch(err => console.error("Errore nel caricamento dei dati:", err));

  
const suggestionsList = document.getElementById("suggestions-list");

// Funzione per aggiornare la lista dei suggerimenti
function updateSuggestions() {
  suggestionIndex = -1;               // Reset dell'indice ad ogni nuovo input
  suggestionsList.innerHTML = "";     // Svuota i suggerimenti esistenti

  const query = searchInput.value.toLowerCase();
  if (query.length === 0) return;       // Se l'input Ã¨ vuoto, non mostra suggerimenti

  // Filtra i temi che iniziano con la query (il confronto Ã¨ case-insensitive)
  const filteredThemes = themes.filter(theme => theme.toLowerCase().startsWith(query));

  // Mostra i primi 5 risultati
  filteredThemes.slice(0, 4).forEach((theme) => {
    const listItem = document.createElement("li");
    listItem.textContent = theme;
    
    // Al click sul suggerimento, aggiorna l'input e pulisci la lista
    listItem.addEventListener("click", () => {
      searchInput.value = theme;
      suggestionsList.innerHTML = "";
      suggestionIndex = -1;
    });
    
    suggestionsList.appendChild(listItem);
  });
}

// Aggiorna i suggerimenti ad ogni modifica dell'input
searchInput.addEventListener("input", updateSuggestions);

// Gestione della navigazione tramite frecce e della selezione con Invio
searchInput.addEventListener("keydown", (e) => {
  const items = suggestionsList.getElementsByTagName("li");

  if (e.key === "ArrowDown") {
    e.preventDefault(); // Previene lo scroll della pagina
    if (items.length === 0) return;
    // Incrementa l'indice (wrap-around opzionale)
    if (suggestionIndex < items.length - 1) {
      suggestionIndex++;
    } else {
      suggestionIndex = 0;
    }
    highlightSuggestion(items, suggestionIndex);

  } else if (e.key === "ArrowUp") {
    e.preventDefault();
    if (items.length === 0) return;
    if (suggestionIndex > 0) {
      suggestionIndex--;
    } else {
      suggestionIndex = items.length - 1;
    }
    highlightSuggestion(items, suggestionIndex);

  } else if (e.key === "Enter") {
    e.preventDefault(); // Previene il comportamento predefinito

    // Se esiste un suggerimento attivo, usalo per aggiornare l'input
    if (suggestionIndex > -1 && items[suggestionIndex]) {
      searchInput.value = items[suggestionIndex].textContent;
    }
    // Pulisci la lista dei suggerimenti e resetta l'indice
    suggestionsList.innerHTML = "";
    suggestionIndex = -1;

    // Triggera la ricerca
    triggerSearch();
  }
});


// Funzione per evidenziare il suggerimento attivo
function highlightSuggestion(items, index) {
  // Rimuove la classe 'active' da tutti gli elementi
  Array.from(items).forEach(item => item.classList.remove("active"));
  // Aggiunge la classe 'active' all'elemento selezionato
  if (items[index]) {
    items[index].classList.add("active");
  }
}

// Nasconde i suggerimenti quando si clicca fuori dall'input o dalla lista
document.addEventListener("click", (e) => {
  if (!searchInput.contains(e.target) && !suggestionsList.contains(e.target)) {
    suggestionsList.innerHTML = "";
    suggestionIndex = -1;
  }
});

async function showDendrogramForTheme(theme) {
  const normalizedTheme = theme.toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, "")
    .replace(/ /g, '-');

  try {
    // 1) Carica la gerarchia dei temi
    const hierarchyResponse = await fetch('https://raw.githubusercontent.com/NicoleLiggeri/retetematica/refs/heads/main/datasets/hierarchy_themes.json');
    const hierarchyData = await hierarchyResponse.json();
    const matches = hierarchyData[normalizedTheme];

    if (!matches) {
      alert(`Nessun tema associato trovato per "${theme}".`);
      return;
    }

    // 2) Carica il dataset principale per calcolare le occorrenze
    const themesResponse = await fetch('https://raw.githubusercontent.com/NicoleLiggeri/retetematica/refs/heads/main/datasets/data.json');
    const themesData = await themesResponse.json();

    // Calcolo delle occorrenze dei temi associati
// 1) Ciclo per calcolare le occorrenze di ogni tema associato
const occurrenceCounts = matches.Associati.reduce((acc, word) => {
  // Normalizza e converte in minuscolo il tema associato
  const normalizedWord = word
    .normalize('NFD')                  // scompone eventuali lettere accentate
    .replace(/[\u0300-\u036f]/g, "")   // rimuove i segni diacritici
    .toLowerCase();

  // Conta quanti item del dataset contengono esattamente quel tema
  const count = themesData.filter(item => {
    if (!item["Temi"]) return false;
    
    // Ricava un array di singole parole (token) dall'attributo "Temi"
    const itemThemesArray = item["Temi"]
      .normalize('NFD').replace(/[\u0300-\u036f]/g, "") // rimuove accenti
      .toLowerCase()
      .split(/\W+/)  // split su qualsiasi carattere non alfanumerico (spazi, virgole, punti, ecc.)
      .filter(Boolean);  // rimuove eventuali stringhe vuote

    // Verifica se normalizedWord Ã¨ presente nell'array dei token
    return itemThemesArray.includes(normalizedWord);
  }).length;

  acc[word] = count;
  return acc;
}, {});

// 2) Occorrenze del tema principale
const mainThemeCount = themesData.filter(item => {
  if (!item["Temi"]) return false;
  
  const itemThemesArray = item["Temi"]
    .normalize('NFD').replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .split(/\W+/)
    .filter(Boolean);

  return itemThemesArray.includes(
    theme
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, "")
      .toLowerCase()
  );
}).length;


    // 3) Nascondi (o disabilita) ciÃ² che non vuoi piÃ¹ vedere (es. il globe e il pannello di destra)
    // Se hai un container con ID #globe-container e #right-panel, puoi nasconderli:
    document.getElementById('globe-container').style.display = 'none';
    document.getElementById('right-panel').style.display = 'none';

    // Nascondi anche il pop-up dellâ€™autore
    document.getElementById('author-details-modal').style.display = 'none';

    // 4) Crea (o svuota) un container dedicato al dendrogramma
    let dendrogramContainer = document.getElementById('dendrogram-container');
    if (!dendrogramContainer) {
      // Se non esiste, crealo e inseriscilo prima del footer
      const app = document.getElementById('app');
      const footer = app.querySelector('footer');
      
      dendrogramContainer = document.createElement('div');
      dendrogramContainer.id = 'dendrogram-container';
      app.insertBefore(dendrogramContainer, footer);
    } else {
      // Se esiste giÃ , lo svuotiamo
      dendrogramContainer.innerHTML = '';
    }

    // 5) Aggiungi un pulsante "Back" per tornare alla vista originale
    const backButton = document.createElement('button');
    backButton.textContent = 'Back';
    backButton.style.margin = '20px';
    backButton.onclick = function() {
      // Rimuovi (o svuota) il dendrogramma
      dendrogramContainer.innerHTML = '';
      // Mostra di nuovo le parti nascoste
      document.getElementById('globe-container').style.display = 'block';
      document.getElementById('right-panel').style.display = 'block';
      document.getElementById('author-details-modal').style.display = 'block';
    };
    dendrogramContainer.appendChild(backButton);

    // 6) Costruisci i dati per il dendrogramma
    const treeData = {
      name: theme,
      count: mainThemeCount,
      children: Object.entries(occurrenceCounts).map(([name, count]) => ({ name, count }))
    };

    // 7) Dimensioni iniziali dell'SVG
    const svgWidth = 800;   // imposta la larghezza desiderata
    const svgHeight = 600;  // imposta l'altezza desiderata

    // Crea lâ€™elemento SVG
    const svg = d3.select(dendrogramContainer)
      .append('svg')
      .attr('width', svgWidth)
      .attr('height', svgHeight)
      .style('border', '1px solid #ccc'); // stile di debug, opzionale

    // 8) Configura il layout ad albero
    const treeLayout = d3.tree()
      .nodeSize([60, 120])
      .separation((a, b) => a.parent === b.parent ? 0.5 : 1);

    // Crea la gerarchia per D3
    const rootNode = d3.hierarchy(treeData);
    treeLayout(rootNode);

    // (Opzionale) Allinea la posizione del nodo padre con i figli
    rootNode.eachAfter(d => {
      if (d.children && d.children.length > 0) {
        d.x = d.children[0].x;
      }
    });

    // Determina i limiti min/max del layout
    const minX = d3.min(rootNode.descendants(), d => d.x);
    const maxX = d3.max(rootNode.descendants(), d => d.x);
    const minY = d3.min(rootNode.descendants(), d => d.y);
    const maxY = d3.max(rootNode.descendants(), d => d.y);

    const margin = { top: 20, right: 50, bottom: 20, left: 50 };
    const calculatedWidth = (maxY - minY) + margin.left + margin.right;
    const calculatedHeight = (maxX - minX) + margin.top + margin.bottom;

    // Adatta effettivamente le dimensioni dellâ€™SVG in base al layout calcolato
    svg
      .attr("width", Math.max(600, calculatedWidth))
      .attr("height", Math.max(400, calculatedHeight));

    // Inserisci un gruppo (g) con margini
    const g = svg.append("g")
      .attr("transform", `translate(${margin.left - minY}, ${margin.top - minX})`);

    // 9) Disegna i collegamenti
    g.selectAll("path")
      .data(rootNode.links())
      .enter()
      .append("path")
      .attr("d", d3.linkHorizontal()
        .x(d => d.y)
        .y(d => d.x)
      )
      .attr("stroke", "#ccc")
      .attr("fill", "none");

    // Calcola il massimo per scalare i nodi (radius)
    const maxCount = d3.max(rootNode.descendants(), d => d.data.count || 1);

    // 10) Disegna i nodi come cerchi
    g.selectAll("circle")
      .data(rootNode.descendants())
      .enter()
      .append("circle")
      .attr("cx", d => d.y)
      .attr("cy", d => d.x)
      .attr("r", d => d.data.count ? (5 + (d.data.count / maxCount) * 20) : 5)
      .attr("fill", d => d.depth === 0 ? 'rgb(251, 126, 0)' : 'rgb(145, 215, 210)');

    // 11) Aggiungi le etichette
    g.selectAll("text")
      .data(rootNode.descendants())
      .enter()
      .append("text")
      .attr("x", d => d.y + 10)
      .attr("y", d => d.x + 10)
      .attr("font-size", "15px")
      .attr("text-anchor", "start")
      .attr("fill", "black")
      .text(d => `${d.data.name} (${d.data.count || 0})`);

  } catch (error) {
    console.error("Errore nella creazione del dendrogramma:", error);
    alert("Si Ã¨ verificato un errore durante la creazione del dendrogramma.");
  }
}

  </script>
  


  
</body>
</html>
