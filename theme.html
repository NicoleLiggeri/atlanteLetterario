<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Radial Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="style.css" />

  <script src="//unpkg.com/globe.gl"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
  <div id="app" class="one-column">
    <header>
      <div>L'Atlante dei temi letterari</div>
      <div id="search-container">
        <input id="search-input" type="text" placeholder="Digita un tema..." />
        <ul id="suggestions-list"></ul>
        <button id="search-button">Cerca</button>
      </div>
    </header>

    <div id="visualization-container">
      <div>
        <svg id="radial-graph"></svg>
      </div>
      <div id="panel">
        <h2>Temi organizzati in macrocategorie</h2>
        <p class="filtered-info">clicca sul grafico per visualizzare la categoria</p>
        <div id="details"></div>
      </div>
    </div>

    <!-- Aggiunto: contenitore per il nuovo contenuto (grid area "container") -->
    <div id="container" style="display: none;"></div>

    <footer>
      <p>2025 Atlante dei Temi Letterari</p>
    </footer>
  </div>

  <script>
d3.json("https://raw.githubusercontent.com/NicoleLiggeri/retetematica/refs/heads/main/datasets/gerarchia_sogg.json").then(data => {
  const maxGraphWidth = 800;
  const width = maxGraphWidth;
  const height = maxGraphWidth;
  const radius = Math.min(width, height) / 2;

  const svg = d3.select("#radial-graph")
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .attr("transform", `translate(${width / 2}, ${height / 2})`);

  const partition = d3.partition().size([2 * Math.PI, radius]);
  const root = d3.hierarchy(data).sum(d => d.children ? 0 : 1);
  partition(root);

  // Generatore per i segmenti "normali"
  const arc = d3.arc()
    .startAngle(d => d.x0)
    .endAngle(d => d.x1)
    .innerRadius(d => d.y0)
    .outerRadius(d => d.y1);

  // Generatore per i segmenti in stato di hover (outerRadius + 10)
  const arcHover = d3.arc()
    .startAngle(d => d.x0)
    .endAngle(d => d.x1)
    .innerRadius(d => d.y0)
    .outerRadius(d => d.y1 + 10);

  const tooltip = d3.select("#tooltip");
  const detailsPanel = d3.select("#details");

  const colorScale = d3.scaleOrdinal([
    "#e4f2f7", "#FB7E00", "#9FC089", "#79B4B0", "#FFCC3F", "#9f9f9f"
  ]);

  // -------------------- ARCHI --------------------
  // Disegno degli archi: tutti i segmenti con figli
  svg.selectAll("path")
    .data(root.descendants().filter(d => d.children))
    .join("path")
    .attr("class", "segment")
    .attr("d", arc)
    .style("fill", d => {
      const baseColor = d.depth === 1 
        ? colorScale(d.data.name)
        : d3.color(colorScale(d.ancestors()[1]?.data.name || d.data.name))
            .brighter(d.depth * 0.25);
      return baseColor;
    })
    .style("stroke", "#fff")
    .on("mouseover", function(event, d) {
      if (d.depth === 0) return;
      // Espandi il segmento corrente
      d3.select(this)
        .transition("arcTransition")
        .duration(200)
        .attr("d", arcHover);
      // Espandi tutti i segmenti discendenti
      if (d.children) {
        svg.selectAll("path")
          .filter(child => child !== d && child.ancestors().indexOf(d) >= 0)
          .transition("childArcTransition")
          .duration(200)
          .attr("d", arcHover);
      }
      this.style.cursor = "pointer";
      tooltip.style("display", "block")
        .style("left", `${event.pageX + 10}px`)
        .style("top", `${event.pageY + 10}px`)
        .html(`<strong>${d.data.name}</strong><br>Totale: ${d.value || "N/A"}`);
      detailsPanel.html(
        `<h2>${d.data.name}</h2>
         <p><strong>Totale:</strong> ${d.value || "N/A"}</p>`
      );
      svg.selectAll("path")
        .filter(nodeData => nodeData === d || nodeData.ancestors().indexOf(d) >= 0)
        .transition("fillTransition")
        .duration(200)
        .style("fill", nodeData => {
          const baseColor = nodeData.depth === 1
            ? colorScale(nodeData.data.name)
            : d3.color(colorScale(nodeData.ancestors()[1]?.data.name || nodeData.data.name))
                .brighter(nodeData.depth * 0.25);
          return d3.color(baseColor).darker(0.5);
        });
    })
    .on("mouseout", function(event, d) {
      d3.select(this)
        .transition("arcTransition")
        .duration(200)
        .attr("d", arc)
        .style("cursor", "default");
      if (d.children) {
        svg.selectAll("path")
          .filter(childData => childData !== d && childData.ancestors().indexOf(d) >= 0)
          .transition("childArcTransition")
          .duration(200)
          .attr("d", arc);
      }
      tooltip.style("display", "none");
      detailsPanel.html(`<p></p>`);
      svg.selectAll("path")
        .filter(nodeData => nodeData === d || nodeData.ancestors().indexOf(d) >= 0)
        .transition("fillTransition")
        .duration(200)
        .style("fill", nodeData => {
          const baseColor = nodeData.depth === 1
            ? colorScale(nodeData.data.name)
            : d3.color(colorScale(nodeData.ancestors()[1]?.data.name || nodeData.data.name))
                .brighter(nodeData.depth * 0.25);
          return baseColor;
        });
    })
    .on("click", function (event, d) {
      if (d.depth === 0) return;
      if (d.children) {
        document.querySelector("#visualization-container").style.display = 'none';
        document.querySelector("#container").style.display = 'block';

        const newHierarchyContainer = document.createElement('div');
        newHierarchyContainer.id = 'new-hierarchy-container';
        document.querySelector("#container").appendChild(newHierarchyContainer);

        function displayChildren(node, previousNodes) {
          newHierarchyContainer.innerHTML = '';
          const backButton = document.createElement('button');
          backButton.textContent = 'Back';
          backButton.style.marginBottom = '20px';
          backButton.onclick = function () {
            if (previousNodes.length > 1) {
              displayChildren(previousNodes[previousNodes.length - 1], previousNodes.slice(0, -1));
            } else {
              document.querySelector("#visualization-container").style.display = 'flex';
              const container = document.querySelector("#container");
              container.removeChild(newHierarchyContainer);
              container.style.display = 'none';
            }
          };
          newHierarchyContainer.appendChild(backButton);
          const childrenList = document.createElement('ul');
          node.children.forEach(child => {
            const listItem = document.createElement('li');
            if (child.children && child.children.length > 0) {
              const toggleBtn = document.createElement('button');
              toggleBtn.textContent = '▼';
              toggleBtn.style.marginRight = '10px';
              toggleBtn.onclick = function () {
                const childUL = listItem.querySelector('ul');
                if (childUL) {
                  childUL.style.display = childUL.style.display === 'none' ? 'block' : 'none';
                  toggleBtn.textContent = childUL.style.display === 'none' ? '▶' : '▼';
                }
              };
              const childName = document.createElement('span');
              childName.textContent = child.data.name;
              listItem.appendChild(toggleBtn);
              listItem.appendChild(childName);
              const childUL = document.createElement('ul');
              childUL.style.display = 'none';
              child.children.forEach(grandChild => {
                const grandChildItem = document.createElement('li');
                grandChildItem.textContent = grandChild.data.name;
                grandChildItem.style.cursor = 'pointer';
                grandChildItem.onclick = function () {
                  createLinearDendrogram(grandChild.data.name, grandChild, child, newHierarchyContainer);
                };
                childUL.appendChild(grandChildItem);
              });
              listItem.appendChild(childUL);
            } else {
              const childName = document.createElement('span');
              childName.textContent = child.data.name;
              childName.style.cursor = 'pointer';
              childName.onclick = function () {
                createLinearDendrogram(child.data.name, child, node, newHierarchyContainer);
              };
              listItem.appendChild(childName);
            }
            childrenList.appendChild(listItem);
          });
          newHierarchyContainer.appendChild(childrenList);
        }
        displayChildren(d, [d]);
      }
    });

  // -------------------- LABEL --------------------
  // Creazione dei label (etichette) con posizionamento condizionale
  // Escludiamo il label del nodo "Tempo" se è al primo livello della gerarchia
  svg.selectAll("text")
    .data(root.descendants().filter(d => d.depth > 0 && d.children && !(d.depth === 1 && d.data.name === "Tempo")))
    .join("text")
    .attr("dy", "0.35em")
    .attr("transform", d => {
      const midAngle = (d.x0 + d.x1) / 2;
      const factor = 0.12;
      const r = d.y0 + (d.y1 - d.y0) * factor;
      if (!labelFits(d)) {
        // Posizionamento esterno: usa il bordo esterno dell'arco + offset
        const offset = 10;
        const newR = d.y1 + offset;
        const x = Math.cos(midAngle - Math.PI / 2) * newR;
        const y = Math.sin(midAngle - Math.PI / 2) * newR;
        d.labelX = x;
        d.labelY = y;
        d.midAngle = midAngle;
        return `translate(${x},${y})`;
      } else {
        const angle = midAngle * 180 / Math.PI - 90;
        return `rotate(${angle})translate(${r},0)${angle > 90 ? "rotate(180)" : ""}`;
      }
    })
    .attr("text-anchor", d => {
      if (!labelFits(d)) {
        return Math.cos(d.midAngle - Math.PI / 2) >= 0 ? "start" : "end";
      } else {
        const midAngle = (d.x0 + d.x1) / 2;
        const angle = midAngle * 180 / Math.PI - 90;
        return angle > 90 ? "end" : "start";
      }
    })
    .attr("fill", "black")
    .attr("font-size", "12px")
    .text(d => d.data.name)
    // ---- AGGIUNTA INTERAZIONE PER I LABEL ----
    .on("mouseover", function(event, d) {
      if (d.depth === 0) return;
      // Espandi il segmento corrispondente (su cui è basato il label)
      svg.selectAll("path").filter(p => p === d)
          .transition("arcTransition")
          .duration(200)
          .attr("d", arcHover);
      if (d.children) {
        svg.selectAll("path")
          .filter(child => child !== d && child.ancestors().indexOf(d) >= 0)
          .transition("childArcTransition")
          .duration(200)
          .attr("d", arcHover);
      }
      d3.select(this).style("cursor", "pointer");
      tooltip.style("display", "block")
             .style("left", `${event.pageX + 10}px`)
             .style("top", `${event.pageY + 10}px`)
             .html(`<strong>${d.data.name}</strong><br>Totale: ${d.value || "N/A"}`);
      detailsPanel.html(
             `<h2>${d.data.name}</h2>
              <p><strong>Totale:</strong> ${d.value || "N/A"}</p>`);
      svg.selectAll("path")
         .filter(nodeData => nodeData === d || nodeData.ancestors().indexOf(d) >= 0)
         .transition("fillTransition")
         .duration(200)
         .style("fill", nodeData => {
           const baseColor = nodeData.depth === 1 
             ? colorScale(nodeData.data.name)
             : d3.color(colorScale(nodeData.ancestors()[1]?.data.name || nodeData.data.name))
                .brighter(nodeData.depth * 0.25);
           return d3.color(baseColor).darker(0.5);
         });
    })
    .on("mouseout", function(event, d) {
      svg.selectAll("path").filter(p => p === d)
         .transition("arcTransition")
         .duration(200)
         .attr("d", arc)
         .style("cursor", "default");
      if (d.children) {
        svg.selectAll("path")
          .filter(child => child !== d && child.ancestors().indexOf(d) >= 0)
          .transition("childArcTransition")
          .duration(200)
          .attr("d", arc);
      }
      tooltip.style("display", "none");
      detailsPanel.html(`<p></p>`);
      svg.selectAll("path")
         .filter(nodeData => nodeData === d || nodeData.ancestors().indexOf(d) >= 0)
         .transition("fillTransition")
         .duration(200)
         .style("fill", nodeData => {
           const baseColor = nodeData.depth === 1 
             ? colorScale(nodeData.data.name)
             : d3.color(colorScale(nodeData.ancestors()[1]?.data.name || nodeData.data.name))
                .brighter(nodeData.depth * 0.25);
           return baseColor;
         });
    })
    .on("click", function(event, d) {
      if (d.depth === 0) return;
      if (d.children) {
        document.querySelector("#visualization-container").style.display = 'none';
        document.querySelector("#container").style.display = 'block';
        const newHierarchyContainer = document.createElement('div');
        newHierarchyContainer.id = 'new-hierarchy-container';
        document.querySelector("#container").appendChild(newHierarchyContainer);
        function displayChildren(node, previousNodes) {
          newHierarchyContainer.innerHTML = '';
          const backButton = document.createElement('button');
          backButton.textContent = 'Back';
          backButton.style.marginBottom = '20px';
          backButton.onclick = function () {
            if (previousNodes.length > 1) {
              displayChildren(previousNodes[previousNodes.length - 1], previousNodes.slice(0, -1));
            } else {
              document.querySelector("#visualization-container").style.display = 'flex';
              const container = document.querySelector("#container");
              container.removeChild(newHierarchyContainer);
              container.style.display = 'none';
            }
          };
          newHierarchyContainer.appendChild(backButton);
          const childrenList = document.createElement('ul');
          node.children.forEach(child => {
            const listItem = document.createElement('li');
            if (child.children && child.children.length > 0) {
              const toggleBtn = document.createElement('button');
              toggleBtn.textContent = '▼';
              toggleBtn.style.marginRight = '10px';
              toggleBtn.onclick = function () {
                const childUL = listItem.querySelector('ul');
                if (childUL) {
                  childUL.style.display = childUL.style.display === 'none' ? 'block' : 'none';
                  toggleBtn.textContent = childUL.style.display === 'none' ? '▶' : '▼';
                }
              };
              const childName = document.createElement('span');
              childName.textContent = child.data.name;
              listItem.appendChild(toggleBtn);
              listItem.appendChild(childName);
              const childUL = document.createElement('ul');
              childUL.style.display = 'none';
              child.children.forEach(grandChild => {
                const grandChildItem = document.createElement('li');
                grandChildItem.textContent = grandChild.data.name;
                grandChildItem.style.cursor = 'pointer';
                grandChildItem.onclick = function () {
                  createLinearDendrogram(grandChild.data.name, grandChild, child, newHierarchyContainer);
                };
                childUL.appendChild(grandChildItem);
              });
              listItem.appendChild(childUL);
            } else {
              const childName = document.createElement('span');
              childName.textContent = child.data.name;
              childName.style.cursor = 'pointer';
              childName.onclick = function () {
                createLinearDendrogram(child.data.name, child, node, newHierarchyContainer);
              };
              listItem.appendChild(childName);
            }
            childrenList.appendChild(listItem);
          });
          newHierarchyContainer.appendChild(childrenList);
        }
        displayChildren(d, [d]);
      }
    });

  // -------------------- COLLISION RESOLUTION PER I LABEL ESTERNI --------------------
  const minDistance = 15; // distanza minima in pixel
  const externalLabels = svg.selectAll("text").filter(d => !labelFits(d));

  const groups = { left: [], right: [] };
  externalLabels.each(function(d) {
    if (d.labelX < 0) groups.left.push({ node: this, d: d });
    else groups.right.push({ node: this, d: d });
  });

  [groups.left, groups.right].forEach(group => {
    group.sort((a, b) => a.d.labelY - b.d.labelY);
    for (let i = 1; i < group.length; i++) {
      const prev = group[i - 1];
      const curr = group[i];
      if (curr.d.labelY - prev.d.labelY < minDistance) {
        curr.d.labelY = prev.d.labelY + minDistance;
      }
    }
    group.forEach(item => {
      d3.select(item.node).attr("transform", `translate(${item.d.labelX},${item.d.labelY})`);
    });
  });
});

// Funzione helper per verificare se il testo entra nella fetta
function labelFits(d) {
  const factor = 0.12;
  const r = d.y0 + (d.y1 - d.y0) * factor;
  const arcAngle = d.x1 - d.x0;
  const availableArcLength = arcAngle * r;
  const estimatedTextLength = d.data.name.length * 1.1;
  return estimatedTextLength <= availableArcLength;
}

// Funzione per creare il dendrogramma lineare.
// Aggiungiamo un quarto parametro: "intermediateContainer" (il contenitore della vista intermedia)
async function createLinearDendrogram(searchTerm, node, parentNode, intermediateContainer) {
  // Normalizziamo (e rimuoviamo gli accenti) da subito il searchTerm per le chiavi del JSON
  const normalizedSearchTerm = searchTerm.toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, "")
    .replace(/ /g, '-');

  try {
    const response = await fetch('https://raw.githubusercontent.com/NicoleLiggeri/retetematica/refs/heads/main/datasets/hierarchy_themes.json');
    const hierarchyData = await response.json();
    const matches = hierarchyData[normalizedSearchTerm];

    if (matches) {
      const themesResponse = await fetch('https://raw.githubusercontent.com/NicoleLiggeri/retetematica/refs/heads/main/datasets/data.json');
      const themesData = await themesResponse.json();

      // 1) Calcola le occorrenze per i termini associati (ricerca esatta fra token)
      const occurrenceCounts = matches.Associati.reduce((acc, word) => {
        // Normalizza il termine associato
        const normalizedWord = word
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, "")
          .toLowerCase();

        // Conta quante volte "normalizedWord" appare come token esatto in item["Temi"]
        const count = themesData.filter(item => {
          if (!item["Temi"]) return false;

          const itemThemesArray = item["Temi"]
            .normalize('NFD').replace(/[\u0300-\u036f]/g, "")
            .toLowerCase()
            .split(/\W+/)
            .filter(Boolean);

          return itemThemesArray.includes(normalizedWord);
        }).length;

        acc[word] = count;
        return acc;
      }, {});

      // 2) Calcola le occorrenze esatte del tema principale (searchTerm)
      const mainThemeCount = themesData.filter(item => {
        if (!item["Temi"]) return false;

        const itemThemesArray = item["Temi"]
          .normalize('NFD').replace(/[\u0300-\u036f]/g, "")
          .toLowerCase()
          .split(/\W+/)
          .filter(Boolean);

        const normalizedRootTheme = searchTerm
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, "")
          .toLowerCase();

        return itemThemesArray.includes(normalizedRootTheme);
      }).length;

      // 3) Crea il contenitore per il dendrogramma
      const dendrogramContainer = document.createElement('div');
      dendrogramContainer.className = 'dendrogram-container';
      // Nascondi la vista intermedia
      intermediateContainer.style.display = 'none';
      document.querySelector("#container").appendChild(dendrogramContainer);

      // <<-- AGGIUNTA DEL TITOLO E DELLA SEZIONE INFO -->> 
      // Crea l'elemento h1 con il nome del tema
      const themeTitleEl = document.createElement('h1');
      themeTitleEl.textContent = searchTerm;
      dendrogramContainer.appendChild(themeTitleEl);

      // Crea la div per le info e inserisce un bottone con icona "globo"
      const themeInfoDiv = document.createElement('div');
      themeInfoDiv.className = 'theme-info';
      themeInfoDiv.innerHTML = `<p>Informazioni sul tema ${searchTerm}</p>`;
      
      // Bottone con un'icona di globo (puoi personalizzare l'SVG o sostituirlo con una classe iconica)
      const globeButton = document.createElement('button');
      globeButton.className = 'globe-button';
      globeButton.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8z"/>
          <path d="M2.05 11H5c.165 0 .33.006.493.017C5.175 8.674 5.907 6.441 7.34 4.68L5.636 2.977C4.107 4.572 2.984 6.746 2.05 9zM22 11h2.95c-.934-2.254-2.057-4.428-3.586-6.023l-1.704 1.703C18.093 6.559 18.825 8.793 18.507 11H22zm-9 9c2.207 0 4-1.793 4-4h-4v4zm-2-9H2.05c.934 2.254 2.057 4.428 3.586 6.023l1.704-1.703C5.907 17.441 5.175 15.207 5.493 13H10v2z"/>
        </svg>`;
      themeInfoDiv.appendChild(globeButton);
      dendrogramContainer.appendChild(themeInfoDiv);
      // <<-- FINE AGGIUNTA -->> 

      // Pulsante "Back" per tornare alla vista intermedia
      const backButton = document.createElement('button');
      backButton.textContent = 'Back';
      backButton.style.marginBottom = '20px';
      backButton.onclick = function () {
        dendrogramContainer.remove();
        intermediateContainer.style.display = 'block';
      };
      dendrogramContainer.appendChild(backButton);

      // 4) Assegna al nodo principale il valore del conteggio calcolato
      const treeData = {
        name: searchTerm,
        count: mainThemeCount,
        children: Object.entries(occurrenceCounts).map(([name, count]) => ({ name, count }))
      };

      // 5) Setup dell'SVG e del layout
      const svgLinear = d3.select(dendrogramContainer)
        .append('svg')
        .attr('width', window.innerWidth)
        .attr('height', window.innerHeight);

      const treeLayout = d3.tree()
        .nodeSize([60, 120])
        .separation((a, b) => a.parent === b.parent ? 0.5 : 1);
        
      const rootLinear = d3.hierarchy(treeData);
      treeLayout(rootLinear);

      // (Opzionale) allineiamo la posizione del nodo padre con i figli
      rootLinear.eachAfter(d => {
        if (d.children && d.children.length > 0) {
          d.x = d.children[0].x;
        }
      });

      // Determiniamo i limiti minimi e massimi delle coordinate
      const minX = d3.min(rootLinear.descendants(), d => d.x);
      const maxX = d3.max(rootLinear.descendants(), d => d.x);
      const minY = d3.min(rootLinear.descendants(), d => d.y);
      const maxY = d3.max(rootLinear.descendants(), d => d.y);

      const margin = { top: 20, right: 50, bottom: 20, left: 50 };
      const svgWidth = (maxY - minY) + margin.left + margin.right;
      const svgHeight = (maxX - minX) + margin.top + margin.bottom;

      svgLinear
        .attr("width", Math.max(600, svgWidth))
        .attr("height", svgHeight);

      const g = svgLinear.append("g")
        .attr("transform", `translate(${margin.left - minY}, ${margin.top - minX})`);

      // 6) Disegniamo i collegamenti tra nodi
      g.selectAll('path')
        .data(rootLinear.links())
        .enter()
        .append('path')
        .attr('d', d3.linkHorizontal()
          .x(d => d.y)
          .y(d => d.x))
        .attr('stroke', '#ccc')
        .attr('fill', 'none');

      // 7) Disegniamo i nodi con dimensioni scalate in base a count
      const maxCount = d3.max(rootLinear.descendants(), d => d.data.count || 1);
      g.selectAll('circle')
        .data(rootLinear.descendants())
        .enter()
        .append('circle')
        .attr('cx', d => d.y)
        .attr('cy', d => d.x)
        .attr('r', d => d.data.count ? (5 + (d.data.count / maxCount) * 20) : 5)
        .attr('fill', d => d.depth === 0 ? 'rgb(251, 126, 0)' : 'rgb(145, 215, 210)');

      // 8) Etichette con il nome e il conteggio di ciascun nodo
      g.selectAll('text')
        .data(rootLinear.descendants())
        .enter()
        .append('text')
        .attr('x', d => d.y + 10)
        .attr('y', d => d.x + 10)
        .attr('font-size', '15px')
        .attr('text-anchor', 'start')
        .attr('fill', 'black')
        .text(d => `${d.data.name} (${d.data.count || 0})`);
    }
  } catch (error) {
    console.error('Error fetching data for linear dendrogram:', error);
  }
}

 </script>
  
  
</body>
</html>